(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{412:function(e,a,s){"use strict";s.r(a);var t=s(52),n=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"esmascript6-模块导读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#esmascript6-模块导读"}},[e._v("#")]),e._v(" ESMAScript6 模块导读")]),e._v(" "),s("h2",{attrs:{id:"es6-有哪些新特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-有哪些新特性"}},[e._v("#")]),e._v(" ES6 有哪些新特性？")]),e._v(" "),s("ul",[s("li",[e._v("let const 与 var 的区别")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("\n1: var 声明的变量有变量提升 let  const 没有\n2：let 声明为变量 const 为常量\n3：const 复制对象或者数组，对象与数组可以被改变便，因为const 保证的指针不变\n4：let const 变量 为块级作用域\n5：let const 变量不能重复\n6: let const 会形成暂时性死区\n\n")])])]),s("ul",[s("li",[e._v("详细介绍promise")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1：因为传统异步是通过回到函数方式结果的，为了解决回调地狱导致代码可读性差，可维护成本，所以有了promise\n2: promise 三种状态 pending（进行中） resolve（已完成） reject（已拒绝）\n3：promise中原型上方法 then catch  catch不会所有的错误，then 执行状态改变，then返回新的promise,then也可以执行 下一个prmise 任务。支持.then 通过链式调用完成多个异步任务\n4：new Promise 中函数为同步执行  .then中函数为异步执行了\n5：Promise 上静态方法：all  race resolve reject 等  \n   - all 处理并发业务，所有的都成功了执行then \n   - race 多个promise 中 有一个成功了执行then \n   - resolve 将状态变为已完成\n   - reject  将状态变为已拒绝\n\n")])])]),s("ul",[s("li",[e._v("promise 中那些是异步的那些是同步的")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("new promise 中函数 为同步\n\n.then .catch 中函数为异步\n\n")])])]),s("ul",[s("li",[e._v("如何解决回调地狱代码可读性差")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("promise\n")])])]),s("ul",[s("li",[e._v("谈谈你对 async awiat 的理解")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1: async 函数 返回值为 promie实例\n2：await 只能在 async 中使用\n3：async awati 同步写法异步的程序\n4：await 后面需要跟 promise 实例\n   - async 返回的    ----\x3e await返回值  return\n   - new Promise    -----\x3e await 返回值 resolve实参\n   - then 返回的promise ----\x3e await 返回值 then中函数的 return\n\n")])])]),s("ul",[s("li",[e._v("说一下class 的作用")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("是 es6中新增的class 类型\n1：可以实例化对象\n2: extends 继承\n3：constructor 构造器，当class 类执行时候；触发constructor 狗爪槭\n4：super 触发父类中的构造器\n5：static 关键字可以定义，类的静态属性和静态方法\n")])])]),s("ul",[s("li",[e._v("class 中super 你是怎么应用的")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1：触发父类的构造器\n2：在子类中调用父类的静态方法\n\n")])])]),s("ul",[s("li",[e._v("es6 对象扩展有那些内容")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1：解构赋值  \n2：对象属性简写\n3：扩展运算符\n")])])]),s("ul",[s("li",[e._v("异步编程语言进化的过程是什么？")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("回调函数---\x3e promise ---\x3egenerator ----\x3easync await\n")])])]),s("ul",[s("li",[e._v("请说出箭头函数有什么特点")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1: 匿名函数改为箭头函数\n2：没有this 使用上一层中的this\n3: 没有arguemets  用 rest 参数代替\n\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);